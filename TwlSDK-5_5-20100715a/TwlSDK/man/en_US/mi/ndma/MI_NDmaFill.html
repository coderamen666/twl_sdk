<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=windows-1252">
<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 7.0.1.0 for Windows">
<META http-equiv="Content-Style-Type" content="text/css">
<TITLE>MI_NDmaFill*</TITLE>
<LINK rel="stylesheet" href="../../css/nitro.css" type="text/css">
</HEAD>
<BODY>
<H1 align="left">MI_NDmaFill* <IMG src="../../image/TWL.gif" width="24" height="12" border="0" align=middle></H1>
<H2>Syntax</H2>
<DL>
<DD><CODE>#include &lt;twl/mi.h&gt;</CODE><BR> <BR> <CODE>void MI_NDmaFill( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFill_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillAsync( u32 dmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaCallback callback, void* arg );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillAsync_SetUp( u32 dmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaCallback callback, void* arg );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillEx( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT>  <CODE>            MINDmaConfig *config );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillEx_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT>  <CODE>            MINDmaConfig *config );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillExAsync( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaCallback callback, void* arg,</CODE>
<DD>                <CODE> MINDmaConfig *config</CODE><CODE> );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillExAsync_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaCallback callback, void* arg,</CODE>
<DD>                <CODE> MINDmaConfig *config</CODE><CODE> );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFill_Dev( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFill_Dev_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillAsync_Dev( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>              MINDmaCallback callback, void* arg,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillAsync_Dev_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>              MINDmaCallback callback, void* arg,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillEx_Dev( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaConfig *config,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillEx_Dev_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>             MINDmaConfig *config,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillExAsync_Dev( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>              MINDmaCallback callback, void* arg,</CODE>
<DD>                <CODE>MINDmaConfig *config,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<DL>
<DD><CODE>void MI_NDmaFillExAsync_Dev_SetUp( u32 ndmaNo,</CODE>
<DT>                    <CODE>void* dest, u32 data, u32 size,</CODE>
<DT><CODE>              MINDmaCallback callback, void* arg,</CODE>
<DD>                <CODE>MINDmaConfig *config,</CODE>
<DT><CODE>             MINDmaDevice dev );</CODE>
</DL>
<H2>Arguments</H2>
<TABLE border="1" width="100%">
  <TBODY>
    <TR>
<TD width="13%"><SPAN class="argument">ndmaNo</SPAN></TD>
<TD width="87%">DMA channel to use (0-3 within the new DMA)</TD>
    </TR>
    <TR>
<TD width="13%"><SPAN class="argument">dest</SPAN></TD>
<TD width="87%">Transfer destination address</TD>
    </TR>
    <TR>
<TD width="13%"><SPAN class="argument">data</SPAN></TD>
<TD width="87%">Fill data</TD>
    </TR>
    <TR>
<TD><SPAN class="argument">size</SPAN></TD>
<TD>Transfer size</TD>
    </TR>
    <TR>
<TD><SPAN class="argument">callback</SPAN></TD>
<TD>Callback when DMA ends</TD>
    </TR>
    <TR>
<TD><SPAN class="argument">arg</SPAN></TD>
<TD>Callback argument when DMA ends</TD>
    </TR>
    <TR>
<TD><SPAN class="argument">config</SPAN></TD>
<TD>DMA configuration</TD>
    </TR>
    <TR>
<TD><SPAN class="argument">dev</SPAN></TD>
<TD>Device (if starting a device)</TD>
    </TR>
  </TBODY>
</TABLE>
<H2>Return Values</H2>
<P>None.</P>
<H2>Description</H2>
<P>Uses the new DMA to fill data.<BR> (The <CODE>*_SetUp</CODE> functions configure the DMA settings but do not transfer data.)</P>
<P>The <CODE>MI_NDmaFill*</CODE> functions use the TWL's new DMA to fill data in word (4-byte) units. The transfer destination address (<SPAN class="argument">dest</SPAN>) must be 4-byte aligned. The transfer size (<SPAN class="argument">size</SPAN>) needs to be a multiple of 4.</P>
<P>Specify the new DMA to use as a number between 0 and 3, in <SPAN class="argument">ndmaNo</SPAN>.</P>
<P>The <SPAN class="argument">data</SPAN> argument is the data to fill in the specified region.</P>
<P>The <CODE>MI_NDmaFill*</CODE> functions include functions for the separate operations given below.</P>
<P>-Whether to wait for DMA shutdown inside the function<BR>-Whether to use defaults for advanced DMA settings or user specifications<BR>-Whether to start DMA immediately, or start it based on an interrupt from a peripheral device</P>
<P> Note that the <CODE>*_SetUp</CODE> functions configure the DMA settings but do not transfer data. To start DMA, call the <A href="MI_NDmaRestart.html"><CODE>MI_NDmaRestart</CODE></A> function.<BR>
</P>
<TABLE border="1">
  <TBODY>
    <TR>
<TH>Functions</TH>
<TH>Wait for DMA Completion in the Function</TH>
<TH>Detailed DMA Settings</TH>
<TH>Start DMA</TH>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFill</CODE></TD>
<TD>Yes</TD>
<TD>Default</TD>
<TD>Immediately</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFillAsync</CODE></TD>
<TD>No (Async)</TD>
<TD>Default</TD>
<TD>Immediately</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFill</CODE></TD>
<TD>Yes</TD>
<TD>User-defined</TD>
<TD>Immediately</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFillExAsync</CODE></TD>
<TD>No (Async)</TD>
<TD>User-defined</TD>
<TD>Immediately</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFill_Dev</CODE></TD>
<TD>Yes</TD>
<TD>Default</TD>
<TD>Interrupt from peripheral device</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFillAsync_Dev</CODE></TD>
<TD>No (Async)</TD>
<TD>Default</TD>
<TD>Interrupt from peripheral device</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFill_Dev</CODE></TD>
<TD>Yes</TD>
<TD>User-defined</TD>
<TD>Interrupt from peripheral device</TD>
    </TR>
    <TR>
<TD><CODE>MI_NDmaFillExAsync_Dev</CODE></TD>
<TD>No (Async)</TD>
<TD>User-defined</TD>
<TD>Interrupt from peripheral device</TD>
    </TR>
  </TBODY>
</TABLE>
<P><BR>
</P>
<P>The <CODE>Async-type functions</CODE> calls the callback specified in <SPAN class="argument">callback</SPAN> upon DMA completion. The callback is of type <CODE>MINDmaCallback</CODE> (a <code>void</code>-type function that takes one of the <code>void*</code> arguments). The <SPAN class="argument">callback</SPAN> argument is called from the system DMA interrupt handler and therefore is called even if interrupts are prohibited.</P>
<P>To achieve maximum functionality, it is necessary to understand how to use Async-type functions.<BR>For more information, see the <A href="../dma/MI_DmaCopy.html"><CODE>MI_DmaCopy</CODE></A> function.</P>
<P>The <SPAN class="argument">config</SPAN> argument is a pointer to the structure that determines the details of the DMA behavior.</P>
<P>The <SPAN class="argument">dev</SPAN> argument indicates the device when performing DMA upon startup of a peripheral device. For the values that can be set, see <A href="about_ndma.html#MINDmaDevice">&quot;DMA Start Timing&quot; in <B>New DMA: Overview</B></A></P>
<H2>Internal Operation</H2>
<P>Uses the new I/O DMA registers.</P>
<H2>See Also</H2>
<P><A href="MI_NDmaCopy.html"><CODE>MI_NDmaCopy*</CODE></A><BR> <A href="MI_NDmaClear.html"><CODE>MI_NDmaClear*</CODE></A><BR> <A href="../dma/MI_DmaFill.html"><CODE>MI_DmaFill*</CODE></A><BR> <A href="../memory/MI_CpuFill.html"><CODE>MI_CpuFill*</CODE></A><BR> <A href="MI_NDmaRestart.html"><CODE>MI_NDmaRestart</CODE></A><BR> <A href="about_ndma.html">New NDMA: Overview</A></P>
<H2>Revision History</H2>
<P>2008/11/19 Added the link for <CODE>MINDmaDevice</CODE>. <BR>2007/10/31 Added <CODE>_SetUp</CODE>. <BR>2007/09/06 Initial version.</P>
<hr><p>CONFIDENTIAL</p></body>
</HTML>
